#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdint.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* -------------------------------- Basic types ----------------------------- */
typedef uint8_t u8; 
typedef uint32_t u32; 
typedef int32_t i32; 
typedef float f32; 
typedef double f64;

#ifndef bool
#define bool int
#define true 1
#define false 0
#endif

/* -------------------------------- Backbuffer ------------------------------ */
typedef struct { int width, height, pitch; void* memory; BITMAPINFO bmi; } Backbuffer;
static Backbuffer g_back;
static int g_running = 1;

static void ResizeBackbuffer(Backbuffer* bb, int w, int h) {
	if (w < 1) w = 1; if (h < 1) h = 1;
	if (bb->memory) { VirtualFree(bb->memory, 0, MEM_RELEASE); bb->memory = 0; }
	bb->width = w; bb->height = h; bb->pitch = w * 4;
	ZeroMemory(&bb->bmi, sizeof(bb->bmi));
	bb->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bb->bmi.bmiHeader.biWidth = w; bb->bmi.bmiHeader.biHeight = -h; /* top-down */
	bb->bmi.bmiHeader.biPlanes = 1; bb->bmi.bmiHeader.biBitCount = 32; bb->bmi.bmiHeader.biCompression = BI_RGB;
	bb->memory = VirtualAlloc(0, bb->pitch * h, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}


static void PresentBackbuffer(HDC dc, Backbuffer* bb) {
	StretchDIBits(dc, 0, 0, bb->width, bb->height, 0, 0, bb->width, bb->height,
		bb->memory, &bb->bmi, DIB_RGB_COLORS, SRCCOPY);
}


static void Clear(u32 color) {
	int y; u32* row = (u32*)g_back.memory;
	for (y = 0; y < g_back.height; y++) {
		int x; for (x = 0; x < g_back.width; x++) row[x] = color;
		row = (u32*)((u8*)row + g_back.pitch);
	}
}


/*-------------------------- Raster Helpers ---------------------------------*/

static void PutPixel(int x, int y, u32 color) {
	if ((unsigned)x < (unsigned)g_back.width && (unsigned)y < (unsigned)g_back.height) {
		u8* row = (u8*)g_back.memory + y * g_back.pitch;
		((u32*)row)[x] = color;
	}
}

static void FillRect(int x, int y, int w, int h, u32 color) {
	if (w <= 0 || h <= 0) return;

	int x0 = x, y0 = y, x1 = x + w, y1 = y + h;
	
	if (x0 < 0) x0 = 0; 
	if (y0 < 0) y0 = 0;
	
	if (x1 > g_back.width)  x1 = g_back.width;
	if (y1 > g_back.height) y1 = g_back.height;
	
	for (int yy = y0; yy < y1; ++yy) {
		u32* row = (u32*)((u8*)g_back.memory + yy * g_back.pitch);
		for (int xx = x0; xx < x1; ++xx) row[xx] = color;
	}
}

/* ------------------------- Win32 Plumbing ---------------------------------*/

static HWND g_hWnd; 
static HDC g_hdc;

static LARGE_INTEGER g_qpcFreq;

static LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM w, LPARAM l) {
	switch (msg) {
	case WM_SIZE: ResizeBackbuffer(&g_back, LOWORD(l), HIWORD(l)); return 0;
	case WM_CLOSE: case WM_DESTROY: g_running = 0; PostQuitMessage(0); return 0;
	default: return DefWindowProc(hWnd, msg, w, l);
	}
}

int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmd, int nShow) {
	
	WNDCLASS wc; 
	ZeroMemory(&wc, sizeof(wc)); 
	wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = WndProc; 
	wc.hInstance = hInst; 
	wc.lpszClassName = "Portal FPS"; 
	
	RegisterClass(&wc);
	g_hWnd = CreateWindowEx(
		0, wc.lpszClassName, "Portal FPS", 
		WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		CW_USEDEFAULT, CW_USEDEFAULT, 960, 540, 
		0, 0, hInst, 0
	);
	
	RECT r; 
	GetClientRect(g_hWnd, &r); 	
	ResizeBackbuffer(&g_back, r.right - r.left, r.bottom - r.top);

	g_hdc = GetDC(g_hWnd);
	QueryPerformanceFrequency(&g_qpcFreq);
	LARGE_INTEGER last; QueryPerformanceCounter(&last);

	while (g_running) {
		MSG m; 
		while (PeekMessage(&m, 0, 0, 0, PM_REMOVE)) { if (m.message == WM_QUIT) g_running = 0; else { TranslateMessage(&m); DispatchMessage(&m); } }
		
		if (!g_running) break;

		if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) g_running = 0;

		LARGE_INTEGER now; QueryPerformanceCounter(&now);
		double dt = (double)(now.QuadPart - last.QuadPart) / (double)g_qpcFreq.QuadPart;
		last = now; (void)dt; // dt is used for camera and physics. 
	
		Clear(0x00202020); // dark gray background

		// visual sanity
		int cx = g_back.width / 2, cy = g_back.height / 2;
		FillRect(cx - 2, cy - 2, 5, 5, 0x00FFFFFF); // white 5x5 square

		// moving test bar (proves per frame draw + dt is working
		static double t = 0.0;
		t += dt;
		int barX = (int)((g_back.width * (0.5 + 0.45 * sin(t))) - 30);
		FillRect(barX, 30, 60, 20, 0x00FFA500); // orange bar

		PresentBackbuffer(g_hdc, &g_back);
	}

	ReleaseDC(g_hWnd, g_hdc);
	return 0;
}