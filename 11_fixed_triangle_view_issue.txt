#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdint.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* -------------------------------- Basic types ----------------------------- */
typedef uint8_t  u8;
typedef uint32_t u32;
typedef int32_t  i32;
typedef float    f32;
typedef double   f64;

#ifndef __cplusplus
#ifndef bool
#define bool int
#define true 1
#define false 0
#endif
#endif

/* -------------------------------- Backbuffer ------------------------------ */
typedef struct { int width, height, pitch; void* memory; BITMAPINFO bmi; } Backbuffer;
static Backbuffer g_back;
static int g_running = 1;

/* ------------------------- Player / Camera -------------------------------- */
typedef struct {
    f32 x, z;                  /* position on ground plane */
    f32 yaw;                   /* radians, 0 = +X, CCW */
    f32 move_speed_mps;        /* speed units per second */
    f32 mouse_sens_rad_per_px; /* yaw radians per mouse pixel */
    f32 radius;                /* collision radius (units) */
    f32 eye_y;                 /* eye height above floor */
} Player;

static Player g_player = { -2.0f, 0.0f, 0.0f, 3.0f, 0.0020f, 0.20f, 1.0f };
static bool   g_mouse_captured = false;

/* ------------------------------ Backbuffer -------------------------------- */
static void ResizeBackbuffer(Backbuffer* bb, int w, int h) {
    if (w < 1) w = 1; if (h < 1) h = 1;
    if (bb->memory) { VirtualFree(bb->memory, 0, MEM_RELEASE); bb->memory = 0; }
    bb->width = w; bb->height = h; bb->pitch = w * 4;
    ZeroMemory(&bb->bmi, sizeof(bb->bmi));
    bb->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bb->bmi.bmiHeader.biWidth = w; bb->bmi.bmiHeader.biHeight = -h; /* top-down */
    bb->bmi.bmiHeader.biPlanes = 1; bb->bmi.bmiHeader.biBitCount = 32; bb->bmi.bmiHeader.biCompression = BI_RGB;
    bb->memory = VirtualAlloc(0, bb->pitch * h, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}
static void PresentBackbuffer(HDC dc, Backbuffer* bb) {
    StretchDIBits(dc, 0, 0, bb->width, bb->height, 0, 0, bb->width, bb->height,
        bb->memory, &bb->bmi, DIB_RGB_COLORS, SRCCOPY);
}
static void Clear(u32 color) {
    int y; u32* row = (u32*)g_back.memory;
    for (y = 0; y < g_back.height; y++) {
        int x; for (x = 0; x < g_back.width; x++) row[x] = color;
        row = (u32*)((u8*)row + g_back.pitch);
    }
}

/* ---------- Tiny raster helpers ------------------------------------------ */
static void PutPixel(int x, int y, u32 color) {
    if ((unsigned)x < (unsigned)g_back.width && (unsigned)y < (unsigned)g_back.height) {
        u8* row = (u8*)g_back.memory + y * g_back.pitch;
        ((u32*)row)[x] = color;
    }
}
static void DrawLine(int x0, int y0, int x1, int y1, u32 color) {
    int dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
    int sx = (x0 < x1) ? 1 : -1;
    int dy = (y1 > y0) ? (y0 - y1) : (y1 - y0); /* dy negative */
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx + dy;
    for (;;) {
        PutPixel(x0, y0, color);
        if (x0 == x1 && y0 == y1) break;
        int e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}
static void FillRect(int x, int y, int w, int h, u32 color) {
    if (w <= 0 || h <= 0) return;
    int x0 = x, y0 = y, x1 = x + w, y1 = y + h;
    if (x0 < 0) x0 = 0; if (y0 < 0) y0 = 0;
    if (x1 > g_back.width)  x1 = g_back.width;
    if (y1 > g_back.height) y1 = g_back.height;
    for (int yy = y0; yy < y1; ++yy) {
        u32* row = (u32*)((u8*)g_back.memory + yy * g_back.pitch);
        for (int xx = x0; xx < x1; ++xx) row[xx] = color;
    }
}

static inline u32 ShadeRGB(u32 c, float f) {
    if (f < 0.0f) f = 0.0f; else if (f > 1.0f) f = 1.0f;
    int r = (c >> 16) & 255, g = (c >> 8) & 255, b = c & 255;
    r = (int)(r * f); g = (int)(g * f); b = (int)(b * f);
    return (u32)((r << 16) | (g << 8) | b);
}


// Draw a vertical filled span at x from y1..y2
static void DrawVerticalSpan(int x, int y1, int y2, u32 color) {
    if (x < 0 || x >= g_back.width) return;
    if (y1 > y2) { int t = y1; y1 = y2; y2 = t; }
    if (y2 < 0 || y1 >= g_back.height) return;
    if (y1 < 0) y1 = 0;
    if (y2 >= g_back.height) y2 = g_back.height - 1;
    u8* base = (u8*)g_back.memory;
    for (int y = y1; y <= y2; ++y) {
        u32* row = (u32*)(base + y * g_back.pitch);
        row[x] = color;
    }
}

// Fast horizontal run fill (clipped)
static void DrawHorizontalRun(int x1, int x2, int y, u32 color) {
    if (y < 0 || y >= g_back.height) return;
    if (x1 > x2) { int t = x1; x1 = x2; x2 = t; }
    if (x2 < 0 || x1 >= g_back.width) return;
    if (x1 < 0) x1 = 0;
    if (x2 >= g_back.width) x2 = g_back.width - 1;

    u8* rowp = (u8*)g_back.memory + y * g_back.pitch;
    u32* row = (u32*)rowp;
    for (int x = x1; x <= x2; ++x) row[x] = color;
}


static int ClampI(int v, int lo, int hi) { if (v < lo) return lo; if (v > hi) return hi; return v; }

/* ------------------------- Win32 Plumbing ---------------------------------*/
static HWND g_hWnd;
static HDC  g_hdc;
static LARGE_INTEGER g_qpcFreq;

static LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM w, LPARAM l) {
    switch (msg) {
    case WM_SIZE:    ResizeBackbuffer(&g_back, LOWORD(l), HIWORD(l)); return 0;
    case WM_CLOSE:
    case WM_DESTROY: g_running = 0; PostQuitMessage(0); return 0;
    default:         return DefWindowProc(hWnd, msg, w, l);
    }
}

/* ------------------------- Mouse capture helpers -------------------------- */
static void CaptureMouse(HWND hwnd) {
    RECT cr; GetClientRect(hwnd, &cr);
    POINT c = { (cr.right - cr.left) / 2, (cr.bottom - cr.top) / 2 };
    ClientToScreen(hwnd, &c);
    SetCursorPos(c.x, c.y);
    ShowCursor(FALSE);
    g_mouse_captured = true;
}
static void ReleaseMouse(void) {
    ShowCursor(TRUE);
    g_mouse_captured = false;
}
static f32 GetMouseDeltaXAndRecenter(HWND hwnd) {
    if (!g_mouse_captured) return 0.0f;
    RECT cr; GetClientRect(hwnd, &cr);
    POINT center = { (cr.right - cr.left) / 2, (cr.bottom - cr.top) / 2 };
    POINT center_screen = center; ClientToScreen(hwnd, &center_screen);
    POINT p; GetCursorPos(&p);
    f32 dx = (f32)(p.x - center_screen.x);
    SetCursorPos(center_screen.x, center_screen.y);
    return dx;
}

/* ------------------------- Input (movement intent) ------------------------ */
static void UpdatePlayerIntent(f32 dt, f32* out_dx, f32* out_dz) {
    /* Mouse look */
    f32 mouse_dx = GetMouseDeltaXAndRecenter(g_hWnd);
    g_player.yaw += mouse_dx * g_player.mouse_sens_rad_per_px;
    while (g_player.yaw < 0.0f)               g_player.yaw += (f32)(2.0f * (f32)M_PI);
    while (g_player.yaw >= (f32)(2.0f * (f32)M_PI)) g_player.yaw -= (f32)(2.0f * (f32)M_PI);

    /* Keyboard */
    int w = (GetAsyncKeyState('W') & 0x8000) ? 1 : 0;
    int s = (GetAsyncKeyState('S') & 0x8000) ? 1 : 0;
    int a = (GetAsyncKeyState('A') & 0x8000) ? 1 : 0;
    int d = (GetAsyncKeyState('D') & 0x8000) ? 1 : 0;

    f32 forward = (f32)(w - s);
    f32 strafe = (f32)(d - a);

    f32 cosY = (f32)cos(g_player.yaw);
    f32 sinY = (f32)sin(g_player.yaw);

    f32 vx = forward * cosY + strafe * (-sinY);
    f32 vz = forward * sinY + strafe * (cosY);

    f32 len2 = vx * vx + vz * vz;
    if (len2 > 0.000001f) {
        f32 invLen = 1.0f / (f32)sqrt(len2);
        vx *= invLen; vz *= invLen;
        f32 step = g_player.move_speed_mps * dt;
        *out_dx = vx * step;
        *out_dz = vz * step;
    }
    else {
        *out_dx = 0.0f; *out_dz = 0.0f;
    }
}

/* ------------------------- Portal map ------------------------------------ */
typedef struct { f32 x, z; } V2;
typedef struct { V2 a, b; int neighbor; } Wall; /* neighbor -1 = solid; >=0 = portal */
typedef struct { int first_wall; int wall_count; f32 floor_y; f32 ceil_y; } Sector;

/* Two rooms with uniform heights */
static Wall g_walls[] = {
    /* Sector 0: [-4,-3]..[4,3], door on right edge z in [-0.5,0.5] */
    {{-4,-3},{-4, 3},-1},
    {{-4, 3},{ 4, 3},-1},
    {{ 4, 3},{ 4, 0.5f},-1},
    {{ 4, 0.5f},{ 4,-0.5f}, 1}, /* portal -> sector 1 */
    {{ 4,-0.5f},{ 4,-3},-1},
    {{ 4,-3},{-4,-3},-1},

    /* Sector 1: [4,-2]..[10,2], matching door on left */
    {{ 4, 2},{ 4, 0.5f},-1},
    {{ 4, 0.5f},{ 4,-0.5f}, 0}, /* portal -> sector 0 */
    {{ 4,-0.5f},{ 4,-2},-1},
    {{ 4,-2},{10,-2},-1},
    {{10,-2},{10, 2},-1},
    {{10, 2},{ 4, 2},-1},
};
static Sector g_sectors[] = {
    { 0, 6, 0.0f, 2.0f },
    { 6, 6, 0.0f, 2.0f },
};
static int g_current_sector = 0;

/* ------------------------- Geometry + collision helpers ------------------- */
static V2 V2Sub(V2 a, V2 b) { V2 r{ a.x - b.x, a.z - b.z }; return r; }
static V2 V2Add(V2 a, V2 b) { V2 r{ a.x + b.x, a.z + b.z }; return r; }
static V2 V2Scale(V2 a, f32 s) { V2 r{ a.x * s, a.z * s }; return r; }
static f32 Dot2(V2 a, V2 b) { return a.x * b.x + a.z * b.z; }
static f32 Cross2(V2 a, V2 b) { return a.x * b.z - a.z * b.x; }

static V2 ClosestPointOnSegment(V2 p, V2 a, V2 b) {
    V2 ab = V2Sub(b, a);
    f32 ab2 = Dot2(ab, ab);
    if (ab2 <= 1e-12f) return a;
    f32 t = Dot2(V2Sub(p, a), ab) / ab2;
    if (t < 0.0f) t = 0.0f; else if (t > 1.0f) t = 1.0f;
    return V2Add(a, V2Scale(ab, t));
}

static int SegmentIntersectParam(V2 p, V2 q, V2 a, V2 b, f32* tHit, f32* uHit) {
    V2 r = V2Sub(q, p);
    V2 s = V2Sub(b, a);
    f32 denom = Cross2(r, s);
    if (fabsf(denom) < 1e-6f) return 0;
    V2 qp = V2Sub(a, p);
    f32 t = Cross2(qp, s) / denom;
    f32 u = Cross2(qp, r) / denom;
    if (t >= 0.0f && t <= 1.0f && u >= 0.0f && u <= 1.0f) {
        if (tHit) *tHit = t;
        if (uHit) *uHit = u;
        return 1;
    }
    return 0;
}

/* Push out of solids to create sliding */
static void ResolveCircleVsSolids(int sector_idx, V2* p, f32 radius) {
    const int max_iters = 4;
    const f32 EPS = 1e-4f;
    for (int iter = 0; iter < max_iters; ++iter) {
        int any_fix = 0;
        Sector sec = g_sectors[sector_idx];
        for (int i = 0; i < sec.wall_count; ++i) {
            Wall w = g_walls[sec.first_wall + i];
            if (w.neighbor >= 0) continue; /* ignore portals */
            V2 cp = ClosestPointOnSegment(*p, w.a, w.b);
            V2 d = V2Sub(*p, cp);
            f32 d2 = Dot2(d, d);
            f32 r2 = radius * radius;
            if (d2 < r2) {
                f32 dlen = sqrtf(d2);
                V2 n;
                if (dlen > 1e-6f) {
                    n = V2Scale(d, 1.0f / dlen);
                }
                else {
                    V2 e = V2Sub(w.b, w.a);
                    n.x = -e.z; n.z = e.x;
                    f32 nlen2 = n.x * n.x + n.z * n.z;
                    if (nlen2 > 0.0f) { f32 inv = 1.0f / sqrtf(nlen2); n.x *= inv; n.z *= inv; }
                    else { n.x = 1.0f; n.z = 0.0f; }
                }
                f32 push = (radius - dlen) + EPS;
                *p = V2Add(*p, V2Scale(n, push));
                any_fix = 1;
            }
        }
        if (!any_fix) break;
    }
}

static void MoveWithPortalsAndSlide(V2 oldP, V2 desiredP) {
    Sector sec = g_sectors[g_current_sector];

    f32 bestT = 2.0f;
    int bestIdx = -1;
    for (int i = 0; i < sec.wall_count; ++i) {
        int widx = sec.first_wall + i;
        Wall w = g_walls[widx];
        f32 t, u;
        if (SegmentIntersectParam(oldP, desiredP, w.a, w.b, &t, &u)) {
            if (t < bestT) { bestT = t; bestIdx = widx; }
        }
    }

    V2 newP = desiredP;

    if (bestIdx >= 0) {
        Wall hit = g_walls[bestIdx];
        if (hit.neighbor >= 0) {
            g_current_sector = hit.neighbor;
            ResolveCircleVsSolids(g_current_sector, &newP, g_player.radius);
            g_player.x = newP.x; g_player.z = newP.z;
            return;
        }
        ResolveCircleVsSolids(g_current_sector, &newP, g_player.radius);
        g_player.x = newP.x; g_player.z = newP.z;
        return;
    }

    ResolveCircleVsSolids(g_current_sector, &newP, g_player.radius);
    g_player.x = newP.x; g_player.z = newP.z;
}

/* ------------------------- 3D portal renderer (wireframe) ----------------- */
// Add vertical clip lines at the left/right edges of the task span
typedef struct {
    int sector;
    int clipL, clipR;
    int prevSector;
    int depth;
    int topL, topR;   // portal top Y at clipL / clipR
    int botL, botR;   // portal bottom Y at clipL / clipR
} RenderTask;

// Interpolate the task's vertical clip at a specific column x
static inline void TaskClipYAt(const RenderTask& t, int x, int* outTop, int* outBot) {
    int w = t.clipR - t.clipL;
    float a = (w != 0) ? (float)(x - t.clipL) / (float)w : 0.0f;
    int top = (int)(t.topL + a * (t.topR - t.topL));
    int bot = (int)(t.botL + a * (t.botR - t.botL));
    if (outTop) *outTop = top;
    if (outBot) *outBot = bot;
}

// Perspective-correct flat fill for a sector's floor/ceiling clipped to task's portal trapezoid
static void FillSectorFloorCeilSpanClipped(const RenderTask& task, int cx, int cy, float focal) {
    const Sector& sec = g_sectors[task.sector];
    const u32 FLOOR_BASE = 0x00262b30u; // tweak to taste
    const u32 CEIL_BASE = 0x001a2230u;

    float dh_floor = g_player.eye_y - sec.floor_y;
    float dh_ceil = sec.ceil_y - g_player.eye_y;

    for (int x = task.clipL; x <= task.clipR; ++x) {
        int topY, botY; TaskClipYAt(task, x, &topY, &botY);

        // Ceiling: from screen top to min(cy-1, topY)
        int ceilMax = topY; if (ceilMax > cy - 1) ceilMax = cy - 1;
        if (dh_ceil > 1e-6f && ceilMax >= 0) {
            for (int y = 0; y <= ceilMax; ++y) {
                float denom = (float)(cy - y) + 0.5f;
                if (denom <= 0.0f) continue;
                float depth = (dh_ceil * focal) / denom;
                float shade = 1.0f / (1.0f + 0.15f * depth); if (shade < 0.25f) shade = 0.25f;
                u32 col = ShadeRGB(CEIL_BASE, shade);
                u32* row = (u32*)((u8*)g_back.memory + y * g_back.pitch);
                row[x] = col;
            }
        }

        // Floor: from max(cy, botY) to bottom
        int floorMin = botY; if (floorMin < cy) floorMin = cy;
        if (dh_floor > 1e-6f && floorMin < g_back.height) {
            for (int y = floorMin; y < g_back.height; ++y) {
                float denom = (float)(y - cy) + 0.5f;
                if (denom <= 0.0f) continue;
                float depth = (dh_floor * focal) / denom;
                float shade = 1.0f / (1.0f + 0.15f * depth); if (shade < 0.25f) shade = 0.25f;
                u32 col = ShadeRGB(FLOOR_BASE, shade);
                u32* row = (u32*)((u8*)g_back.memory + y * g_back.pitch);
                row[x] = col;
            }
        }
    }
}



static void Render3D(void) {
    const float FOV_deg = 75.0f;
    const float halfFOV = (float)(FOV_deg * (M_PI / 180.0f) * 0.5f);
    const float nearPlane = 0.05f;

    const int   cx = g_back.width / 2;
    const int   cy = g_back.height / 2;
    const float focal = (float)cx / tanf(halfFOV);

    const float cosY = cosf(g_player.yaw);
    const float sinY = sinf(g_player.yaw);

    // Optional background for any uncovered pixels
    const u32 SKY_COLOR = 0x00203048u;
    const u32 FLOOR_COLOR = 0x001a1f26u;
    FillRect(0, 0, g_back.width, cy, SKY_COLOR);
    FillRect(0, cy, g_back.width, g_back.height - cy, FLOOR_COLOR);

    // Portal traversal stack with vertical clipping; root sees whole screen
    const int MAX_STACK = 64;
    const int MAX_DEPTH = 16;
    RenderTask stack[MAX_STACK];
    int sp = 0;
    stack[sp++] = RenderTask{ g_current_sector, 0, g_back.width - 1, -1, 0,
                              0, 0, g_back.height - 1, g_back.height - 1 };

    while (sp > 0) {
        RenderTask task = stack[--sp];
        if (task.clipL >= task.clipR) continue;
        if (task.depth > MAX_DEPTH)   continue;

        // Fill this sector's floor/ceiling only inside the portal trapezoid
        FillSectorFloorCeilSpanClipped(task, cx, cy, focal);

        const Sector& sec = g_sectors[task.sector];
        const float ceilY = sec.ceil_y;
        const float floorY = sec.floor_y;

        for (int i = 0; i < sec.wall_count; ++i) {
            const Wall& w = g_walls[sec.first_wall + i];

            // Translate to player
            float ax = w.a.x - g_player.x;
            float az = w.a.z - g_player.z;
            float bx = w.b.x - g_player.x;
            float bz = w.b.z - g_player.z;

            // Rotate by -yaw (camera looks along +X')
            float xa = cosY * ax + sinY * az;  // depth A
            float za = -sinY * ax + cosY * az;  // lateral A
            float xb = cosY * bx + sinY * bz;  // depth B
            float zb = -sinY * bx + cosY * bz;  // lateral B

            // Near-plane reject/clip
            if (xa <= nearPlane && xb <= nearPlane) continue;
            if (xa <= nearPlane || xb <= nearPlane) {
                if (xa < nearPlane && xb > nearPlane) {
                    float t = (nearPlane - xa) / (xb - xa);
                    xa = nearPlane;  za = za + t * (zb - za);
                }
                else if (xb < nearPlane && xa > nearPlane) {
                    float t = (nearPlane - xb) / (xa - xb);
                    xb = nearPlane;  zb = zb + t * (za - zb);
                }
                else {
                    continue;
                }
            }

            // Project to screen X
            int sx1 = cx + (int)((za / xa) * focal);
            int sx2 = cx + (int)((zb / xb) * focal);

            // Sort left -> right (carry depths and laterals)
            int   leftX = sx1, rightX = sx2;
            float leftD = xa, rightD = xb;
            float zL = za, zR = zb;
            if (rightX < leftX) {
                int   ti = leftX;  leftX = rightX;  rightX = ti;
                float tf = leftD;  leftD = rightD;  rightD = tf;
                float tz = zL;     zL = zR;      zR = tz;
            }

            // Cull by horizontal span
            if (rightX < task.clipL || leftX > task.clipR) continue;

            const int spanL = (leftX > task.clipL) ? leftX : task.clipL;
            const int spanR = (rightX < task.clipR) ? rightX : task.clipR;
            if (spanR < spanL) continue;

            // Vertical extents at endpoints
            int yTop1 = cy - (int)(((ceilY - g_player.eye_y) / leftD) * focal);
            int yBottom1 = cy - (int)(((floorY - g_player.eye_y) / leftD) * focal);
            int yTop2 = cy - (int)(((ceilY - g_player.eye_y) / rightD) * focal);
            int yBottom2 = cy - (int)(((floorY - g_player.eye_y) / rightD) * focal);

            // SOLID wall fill, clipped to the task's portal trapezoid
            if (w.neighbor < 0) {
                const u32 BASE = 0x00884444u;
                float invW = (rightX != leftX) ? (1.0f / (float)(rightX - leftX)) : 0.0f;
                for (int x = spanL; x <= spanR; ++x) {
                    float t = (rightX != leftX) ? (float)(x - leftX) * invW : 0.0f;
                    float depth = leftD + t * (rightD - leftD);
                    int yTop = cy - (int)(((ceilY - g_player.eye_y) / depth) * focal);
                    int yBot = cy - (int)(((floorY - g_player.eye_y) / depth) * focal);

                    // Clip to task's vertical portal trapezoid at this x
                    int clipTop, clipBot; TaskClipYAt(task, x, &clipTop, &clipBot);
                    if (yTop < clipTop) yTop = clipTop;
                    if (yBot > clipBot) yBot = clipBot;

                    if (yTop <= yBot) {
                        float shade = 1.0f / (1.0f + 0.15f * depth); if (shade < 0.35f) shade = 0.35f;
                        u32 col = ShadeRGB(BASE, shade);
                        DrawVerticalSpan(x, yTop, yBot, col);
                    }
                }
            }

            // Wireframe edges (clipped to portal)
            u32 edgeColor = (w.neighbor >= 0) ? 0x0044CCFFu : 0x00FF4444u;
            auto clipYAt = [&](int x, int yTop, int yBot)->void {
                int tTop, tBot; TaskClipYAt(task, x, &tTop, &tBot);
                int yt = yTop, yb = yBot;
                if (yt < tTop) yt = tTop;
                if (yb > tBot) yb = tBot;
                if (x >= spanL && x <= spanR && yt <= yb) DrawLine(x, yt, x, yb, edgeColor);
                };
            clipYAt(leftX, yTop1, yBottom1);
            clipYAt(rightX, yTop2, yBottom2);

            // Enqueue neighbor through portal: compute child's vertical clip at portalL/portalR
            if (w.neighbor >= 0) {
                int portalL = spanL;
                int portalR = spanR;
                if (portalR - portalL >= 2 && w.neighbor != task.prevSector && sp < MAX_STACK && task.depth + 1 <= MAX_DEPTH) {
                    // Interpolate wall's top/bot at the clipped edges
                    float invW2 = (rightX != leftX) ? (1.0f / (float)(rightX - leftX)) : 0.0f;
                    float tL = (rightX != leftX) ? (float)(portalL - leftX) * invW2 : 0.0f;
                    float tR = (rightX != leftX) ? (float)(portalR - leftX) * invW2 : 0.0f;

                    int wTopL = (int)(yTop1 + tL * (yTop2 - yTop1));
                    int wBotL = (int)(yBottom1 + tL * (yBottom2 - yBottom1));
                    int wTopR = (int)(yTop1 + tR * (yTop2 - yTop1));
                    int wBotR = (int)(yBottom1 + tR * (yBottom2 - yBottom1));

                    // Intersect with parent's clip at those edges
                    int pTopL, pBotL, pTopR, pBotR;
                    TaskClipYAt(task, portalL, &pTopL, &pBotL);
                    TaskClipYAt(task, portalR, &pTopR, &pBotR);

                    int childTopL = (wTopL > pTopL) ? wTopL : pTopL;
                    int childBotL = (wBotL < pBotL) ? wBotL : pBotL;
                    int childTopR = (wTopR > pTopR) ? wTopR : pTopR;
                    int childBotR = (wBotR < pBotR) ? wBotR : pBotR;

                    if (childTopL <= childBotL && childTopR <= childBotR) {
                        stack[sp++] = RenderTask{
                            w.neighbor, portalL, portalR, task.sector, task.depth + 1,
                            childTopL, childTopR, childBotL, childBotR
                        };
                    }
                }
            }
        }
    }
}


/* ------------------------- 2D Map overlay --------------------------------- */
static void DrawMap2D(void) {
    const int origin_x = 30;
    const int origin_y = g_back.height - 30;
    const float S = 24.0f;

    /* walls */
    for (int s = 0; s < (int)(sizeof(g_sectors) / sizeof(g_sectors[0])); ++s) {
        Sector sec = g_sectors[s];
        for (int i = 0; i < sec.wall_count; ++i) {
            Wall w = g_walls[sec.first_wall + i];
            int x0 = origin_x + (int)(w.a.x * S);
            int y0 = origin_y - (int)(w.a.z * S);
            int x1 = origin_x + (int)(w.b.x * S);
            int y1 = origin_y - (int)(w.b.z * S);
            u32 color = (w.neighbor >= 0) ? 0x0044CCFFu : 0x00FF4444u;
            DrawLine(x0, y0, x1, y1, color);
        }
    }

    /* player (amber in sector 0, cyan in sector 1) */
    int px = origin_x + (int)(g_player.x * S);
    int pz = origin_y - (int)(g_player.z * S);
    u32 pcol = (g_current_sector == 0) ? 0x00FFAA00u : 0x0000FFFFu;
    FillRect(px - 2, pz - 2, 5, 5, pcol);

    /* heading tick */
    int hx = origin_x + (int)((g_player.x + cosf(g_player.yaw) * 0.5f) * S);
    int hz = origin_y - (int)((g_player.z + sinf(g_player.yaw) * 0.5f) * S);
    DrawLine(px, pz, hx, hz, 0x0000FF00u);
}

/* ------------------------- Debug HUD -------------------------------------- */
static void DrawDebugHUD(void) {
    /* crosshair */
    int cx = g_back.width / 2, cy = g_back.height / 2;
    FillRect(cx - 2, cy - 2, 5, 5, 0x00FFFFFF);

    /* 2D map overlay */
    DrawMap2D();
}

/* --------------------------------- WinMain -------------------------------- */
int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmd, int nShow) {
    WNDCLASS wc; ZeroMemory(&wc, sizeof(wc));
    wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = "Portal FPS";

    RegisterClass(&wc);
    g_hWnd = CreateWindowEx(
        0, wc.lpszClassName, "Portal FPS",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT, 960, 540,
        0, 0, hInst, 0
    );

    RECT r; GetClientRect(g_hWnd, &r);
    ResizeBackbuffer(&g_back, r.right - r.left, r.bottom - r.top);

    g_hdc = GetDC(g_hWnd);
    QueryPerformanceFrequency(&g_qpcFreq);
    LARGE_INTEGER last; QueryPerformanceCounter(&last);

    while (g_running) {
        MSG m;
        while (PeekMessage(&m, 0, 0, 0, PM_REMOVE)) {
            if (m.message == WM_QUIT) g_running = 0;
            else { TranslateMessage(&m); DispatchMessage(&m); }
        }
        if (!g_running) break;

        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            g_running = 0;
        }
        if (!g_mouse_captured) {
            SHORT lmb = GetAsyncKeyState(VK_LBUTTON);
            if (lmb & 0x0001) { CaptureMouse(g_hWnd); }
        }

        LARGE_INTEGER now; QueryPerformanceCounter(&now);
        f32 dt = (f32)((double)(now.QuadPart - last.QuadPart) / (double)g_qpcFreq.QuadPart);
        last = now;

        /* Input -> desired delta, then collide/traverse with radius and slide */
        f32 dx = 0.0f, dz = 0.0f;
        UpdatePlayerIntent(dt, &dx, &dz);
        V2 oldP{ g_player.x, g_player.z };
        V2 desiredP{ g_player.x + dx, g_player.z + dz };
        MoveWithPortalsAndSlide(oldP, desiredP);

        Clear(0x00202020);

        /* Render simple 3D view (wireframe) via portals */
        Render3D();

        /* Overlay HUD + 2D map for debugging */
        DrawDebugHUD();

        PresentBackbuffer(g_hdc, &g_back);
    }

    ReleaseMouse();
    ReleaseDC(g_hWnd, g_hdc);
    return 0;
}
