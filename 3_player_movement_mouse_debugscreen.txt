#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdint.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* -------------------------------- Basic types ----------------------------- */
typedef uint8_t  u8;
typedef uint32_t u32;
typedef int32_t  i32;
typedef float    f32;
typedef double   f64;

#ifndef bool
#define bool int
#define true 1
#define false 0
#endif

/* -------------------------------- Backbuffer ------------------------------ */
typedef struct { int width, height, pitch; void* memory; BITMAPINFO bmi; } Backbuffer;
static Backbuffer g_back;
static int g_running = 1;

/* ------------------------- Player / Camera -------------------------------- */
typedef struct {
    f32 x, z;                 /* position on ground plane (y will come later) */
    f32 yaw;                  /* radians, 0 = +X, counterclockwise */
    f32 move_speed_mps;       /* meters per second (arbitrary units for now) */
    f32 mouse_sens_rad_per_px;/* yaw radians per mouse pixel */
} Player;

static Player g_player = { 0.0f, 0.0f, 0.0f, 3.0f, 0.0020f };
static bool   g_mouse_captured = false;

/* -------------------------------- Backbuffer ------------------------------ */
static void ResizeBackbuffer(Backbuffer* bb, int w, int h) {
    if (w < 1) w = 1; if (h < 1) h = 1;
    if (bb->memory) { VirtualFree(bb->memory, 0, MEM_RELEASE); bb->memory = 0; }
    bb->width = w; bb->height = h; bb->pitch = w * 4;
    ZeroMemory(&bb->bmi, sizeof(bb->bmi));
    bb->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bb->bmi.bmiHeader.biWidth = w; bb->bmi.bmiHeader.biHeight = -h; /* top-down */
    bb->bmi.bmiHeader.biPlanes = 1; bb->bmi.bmiHeader.biBitCount = 32; bb->bmi.bmiHeader.biCompression = BI_RGB;
    bb->memory = VirtualAlloc(0, bb->pitch * h, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

static void PresentBackbuffer(HDC dc, Backbuffer* bb) {
    StretchDIBits(dc, 0, 0, bb->width, bb->height, 0, 0, bb->width, bb->height,
        bb->memory, &bb->bmi, DIB_RGB_COLORS, SRCCOPY);
}

static void Clear(u32 color) {
    int y; u32* row = (u32*)g_back.memory;
    for (y = 0; y < g_back.height; y++) {
        int x; for (x = 0; x < g_back.width; x++) row[x] = color;
        row = (u32*)((u8*)row + g_back.pitch);
    }
}

/* ---------- Tiny software raster helpers ---------------------------------- */
static void FillRect(int x, int y, int w, int h, u32 color) {
    if (w <= 0 || h <= 0) return;
    int x0 = x, y0 = y, x1 = x + w, y1 = y + h;
    if (x0 < 0) x0 = 0; if (y0 < 0) y0 = 0;
    if (x1 > g_back.width)  x1 = g_back.width;
    if (y1 > g_back.height) y1 = g_back.height;
    for (int yy = y0; yy < y1; ++yy) {
        u32* row = (u32*)((u8*)g_back.memory + yy * g_back.pitch);
        for (int xx = x0; xx < x1; ++xx) row[xx] = color;
    }
}

/* ------------------------- Win32 Plumbing ---------------------------------*/
static HWND g_hWnd;
static HDC  g_hdc;
static LARGE_INTEGER g_qpcFreq;

static LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM w, LPARAM l) {
    switch (msg) {
    case WM_SIZE:    ResizeBackbuffer(&g_back, LOWORD(l), HIWORD(l)); return 0;
    case WM_CLOSE:
    case WM_DESTROY: g_running = 0; PostQuitMessage(0); return 0;
    default:         return DefWindowProc(hWnd, msg, w, l);
    }
}

/* ------------------------- Mouse capture helpers -------------------------- */
static void CaptureMouse(HWND hwnd) {
    RECT cr; GetClientRect(hwnd, &cr);
    POINT c = { (cr.right - cr.left) / 2, (cr.bottom - cr.top) / 2 };
    ClientToScreen(hwnd, &c);
    SetCursorPos(c.x, c.y);
    ShowCursor(FALSE);
    g_mouse_captured = true;
}

static void ReleaseMouse(void) {
    ShowCursor(TRUE);
    g_mouse_captured = false;
}

/* Return horizontal mouse delta in pixels and recenter the cursor. */
static f32 GetMouseDeltaXAndRecenter(HWND hwnd) {
    if (!g_mouse_captured) return 0.0f;
    RECT cr; GetClientRect(hwnd, &cr);
    POINT center = { (cr.right - cr.left) / 2, (cr.bottom - cr.top) / 2 };
    POINT center_screen = center; ClientToScreen(hwnd, &center_screen);

    POINT p; GetCursorPos(&p);
    f32 dx = (f32)(p.x - center_screen.x);

    /* Recenter for next frame */
    SetCursorPos(center_screen.x, center_screen.y);
    return dx;
}

/* ------------------------- Input and Movement ----------------------------- */
static void UpdatePlayerFromInput(f32 dt, HWND hwnd) {
    /* Click to capture mouse once the window is active */
    if (!g_mouse_captured) {
        SHORT lmb = GetAsyncKeyState(VK_LBUTTON);
        if (lmb & 0x0001) { CaptureMouse(hwnd); }
    }

    /* Mouse look (horizontal only for now) */
    f32 mouse_dx = GetMouseDeltaXAndRecenter(hwnd);
    g_player.yaw += mouse_dx * g_player.mouse_sens_rad_per_px;

    /* Keep yaw in [0, 2*pi) */
    while (g_player.yaw < 0.0f)               g_player.yaw += (f32)(2.0 * M_PI);
    while (g_player.yaw >= (f32)(2.0 * M_PI)) g_player.yaw -= (f32)(2.0 * M_PI);

    /* Keyboard: W/S forward/back, A/D strafe */
    int w = (GetAsyncKeyState('W') & 0x8000) ? 1 : 0;
    int s = (GetAsyncKeyState('S') & 0x8000) ? 1 : 0;
    int a = (GetAsyncKeyState('A') & 0x8000) ? 1 : 0;
    int d = (GetAsyncKeyState('D') & 0x8000) ? 1 : 0;

    f32 forward = (f32)(w - s);
    f32 strafe = (f32)(d - a);

    /* Build movement vector in world space from yaw */
    f32 cosY = (f32)cos(g_player.yaw);
    f32 sinY = (f32)sin(g_player.yaw);

    f32 vx = forward * cosY + strafe * (-sinY);
    f32 vz = forward * sinY + strafe * (cosY);

    /* Normalize to avoid faster diagonal, then scale by speed and dt */
    f32 len2 = vx * vx + vz * vz;
    if (len2 > 0.000001f) {
        f32 invLen = 1.0f / (f32)sqrt(len2);
        vx *= invLen; vz *= invLen;
        f32 step = g_player.move_speed_mps * dt;
        g_player.x += vx * step;
        g_player.z += vz * step;
    }
}

/* ------------------------- Debug HUD -------------------------------------- */
static void DrawDebugHUD(void) {
    /* Center dot */
    int cx = g_back.width / 2, cy = g_back.height / 2;
    FillRect(cx - 2, cy - 2, 5, 5, 0x00FFFFFF);

    /* Heading marker: small dot 20px in the direction of yaw */
    int hx = cx + (int)(cos(g_player.yaw) * 20.0f);
    int hy = cy + (int)(sin(g_player.yaw) * 20.0f);
    FillRect(hx - 2, hy - 2, 4, 4, 0x0000FF00);

    /* Tiny "minimap": draw player as a dot in bottom-left corner area. */
    const float scale = 8.0f; /* pixels per unit */
    int mx = 20 + (int)(g_player.x * scale);
    int my = g_back.height - 20 - (int)(g_player.z * scale);
    FillRect(mx - 2, my - 2, 4, 4, 0x00FFAA00);
}

/* --------------------------------- WinMain -------------------------------- */
int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmd, int nShow) {
    WNDCLASS wc; ZeroMemory(&wc, sizeof(wc));
    wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInst;
    wc.lpszClassName = "Portal FPS";

    RegisterClass(&wc);
    g_hWnd = CreateWindowEx(
        0, wc.lpszClassName, "Portal FPS",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT, 960, 540,
        0, 0, hInst, 0
    );

    RECT r; GetClientRect(g_hWnd, &r);
    ResizeBackbuffer(&g_back, r.right - r.left, r.bottom - r.top);

    g_hdc = GetDC(g_hWnd);
    QueryPerformanceFrequency(&g_qpcFreq);
    LARGE_INTEGER last; QueryPerformanceCounter(&last);

    while (g_running) {
        MSG m;
        while (PeekMessage(&m, 0, 0, 0, PM_REMOVE)) {
            if (m.message == WM_QUIT) g_running = 0;
            else { TranslateMessage(&m); DispatchMessage(&m); }
        }
        if (!g_running) break;

        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            /* If you would rather ESC free mouse instead of exit, call ReleaseMouse() and continue */
            g_running = 0;
        }

        LARGE_INTEGER now; QueryPerformanceCounter(&now);
        f32 dt = (f32)((double)(now.QuadPart - last.QuadPart) / (double)g_qpcFreq.QuadPart);
        last = now;

        /* Update player */
        UpdatePlayerFromInput(dt, g_hWnd);

        /* Frame */
        Clear(0x00202020);
        DrawDebugHUD();
        PresentBackbuffer(g_hdc, &g_back);
    }

    ReleaseMouse();
    ReleaseDC(g_hWnd, g_hdc);
    return 0;
}
